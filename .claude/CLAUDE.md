# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Running the App

```bash
npm run dev      # development server at localhost:5173
npm run build    # production build → dist/
npm run preview  # serve dist/ locally (tests SW + PWA behaviour)
```

PWA features (service worker, install prompt) only fully activate in `preview` mode or production (HTTPS). In `dev` mode, the SW is intentionally not registered.

## Architecture

Svelte 5 + Vite 6 PWA. Three screens rendered conditionally in `App.svelte` with enter/exit transitions.

### File tree

```
src/
  lib/
    constants.js    ← SEGMENT_COLORS, CIRCUMFERENCE, DATA_VERSION, BUILTIN_PRESETS, formatTime
    storage.js      ← lsGet, lsSet, runMigrations, getSessions/saveSessions, getUserPresets/saveUserPresets, getMeditatedDays, getDayCounts, recordToday
    dates.js        ← todayKey, computeStreak, computeBestStreak, getLast7Days, getTodayCount, getStreakMessage, getCalendarData, recordToday
    audio.js        ← initAudio, unlockAudio, createChimeElements, playIntervalChime, playSessionChime, startKeepAlive, stopKeepAlive, ensureAmbientPlaying, scheduleAllChimes, cancelScheduledChimes, setupMediaSession, clearMediaSession
    timer.js        ← computeTimerState() pure function
    transitions.js  ← screenEnter, screenExit (Svelte custom transitions)
  components/
    SetupScreen.svelte
    TimerScreen.svelte
    CelebrationScreen.svelte
  App.svelte        ← root; all cross-screen state + audio orchestration
  main.js           ← runMigrations, initAudio, mount(App)
  app.css           ← global styles (imported in main.js)
public/
  manifest.json
  icon.png
```

### State ownership

All cross-screen state lives in `App.svelte` as Svelte 5 `$state` runes:
- `activeScreen` (`'setup' | 'timer' | 'celebration'`)
- `totalSeconds`, `intervals` — session config
- `sessions` — cumulative count (persisted)
- `isRunning`, `sessionStartTime`, `pausedElapsed` — timer state
- `lastChimedInterval` — missed-chime tracking on iOS wake

`wakeLock` is a plain `let` (not `$state`) — it doesn't affect rendering.

### Screen transitions

`{#key activeScreen}` forces component remount on every screen change, which means all local state in child components is always fresh. Transitions use custom `screenEnter` / `screenExit` functions from `lib/transitions.js`.

## Key Implementation Details

**Timer is timestamp-based**, not tick-counting. `computeTimerState()` in `lib/timer.js` is a pure function using `Date.now()`. TimerScreen calls it via `requestAnimationFrame` — never `setInterval`. This survives iOS screen lock/suspend without drift.

**Audio is generated programmatically** as WAV blobs at startup in `lib/audio.js`. Three sounds: interval chime (singing bowl at 432 Hz), session-complete chime (deep gong at 110 Hz), and a near-silent ambient loop. All `Audio` objects are **module-level variables** in `audio.js` — never put them in `$state` (WebKit proxying breaks the prototype chain).

**iOS audio unlock flow:**
1. `initAudio()` in `main.js` generates blob URLs (no user gesture needed)
2. `unlockAudio()` primes the ambient element on first touch/click (user gesture)
3. `createChimeElements()` called **synchronously** inside `handleStart()` — creates `<audio>` elements within the button's onclick stack

**Service worker** is auto-generated by `vite-plugin-pwa` / Workbox. No manual `service-worker.js`. Cache strategy: NetworkFirst for navigation, CacheFirst for assets.

**localStorage keys** (unchanged from v3):
- `meditationSessions` — cumulative session count
- `meditationDays` — `string[]` of `YYYY-MM-DD` keys for streak computation
- `meditationDayCounts` — `{ [YYYY-MM-DD]: number }` for per-day counts
- `meditationPresets` — user-saved preset objects
- `meditationDataVersion` — migration version marker

## Version Bumping

When making changes, update the version string in **one place**:
- `src/App.svelte` — the `<p class="version-label">v4.0</p>` at the bottom of the template

The service worker cache is now managed by Workbox — cache busting is automatic via content hashes in filenames.
